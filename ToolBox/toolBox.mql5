//+------------------------------------------------------------------+
//|                                           DrawingToolbox.mq5     |
//|                                                  Braiidev (mod)  |
//|                             Powered by ChatGPT                   |
//+------------------------------------------------------------------+
#property indicator_chart_window

//=== CONSTANTES ===//
#define PANEL_Y  20
#define BTN_SIZE 30

//=== VARIABLES GLOBALES ===//
string buttons[]        = {"HLine", "VLine", "Trend", "Rect", "Text", "Dot", "ClearAll", "Show"};
string button_labels[]  = {"â”€", "â”‚", "\\", "â–ˆ", "TXT", "âˆ™", "C", "Â«"};
string button_desc[]    = {"Horizontal line", "Vertical line", "Trend line", "Rectangle", "Textbox", "Dot", "Clear chart", "Toggle toolbox"};
string active_tool      = "";
bool   wait_for_click   = false;
bool   SwitchToolbox    = true; // show toolbox

//+------------------------------------------------------------------+
//| OnInit                                                          |
//+------------------------------------------------------------------+
int OnInit()
 {
  CreatePanel();
  ChartRedraw();
  return(INIT_SUCCEEDED);
 }

//+------------------------------------------------------------------+
//| OnDeinit                                                        |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
 {
  for(int i=0; i<ArraySize(buttons); i++)
    ObjectDelete(0, buttons[i]);
  ClearAllDrawings();
 }

//+------------------------------------------------------------------+
//| OnCalculate                                                     |
//+------------------------------------------------------------------+
int OnCalculate(const int32_t rates_total,
                const int32_t prev_calculated,
                const datetime& time[],
                const double& open[],
                const double& high[],
                const double& low[],
                const double& close[],
                const long& tick_volume[],
                const long& volume[],
                const int& spread[])
 {
  return(rates_total);
 }

//+------------------------------------------------------------------+
//| Crear el panel centrado con los botones                         |
//+------------------------------------------------------------------+
void CreatePanel()
 {
  int chart_width = (int)ChartGetInteger(0, CHART_WIDTH_IN_PIXELS);
  int total_width = ArraySize(buttons) * (BTN_SIZE + 5);
  int panel_x = (chart_width - total_width) / 2; // centrado en eje X

// Si ya existen, elimÃ­nalos para recrear correctamente
  for(int b=0; b<ArraySize(buttons); b++)
    ObjectDelete(0, buttons[b]);

  for(int i=0; i<ArraySize(buttons); i++)
   {
    string name = buttons[i];
    if(!ObjectCreate(0, name, OBJ_BUTTON, 0, 0, 0))
     {
      // si falla la creaciÃ³n, intentar borrar y recrear una vez
      ObjectDelete(0, name);
      ObjectCreate(0, name, OBJ_BUTTON, 0, 0, 0);
     }

    ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, panel_x + i*(BTN_SIZE+5));
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, PANEL_Y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, BTN_SIZE);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, BTN_SIZE);
    ObjectSetInteger(0, name, OBJPROP_BORDER_TYPE, BORDER_FLAT);

    color bg = (name == "ClearAll") ? clrMaroon : clrDimGray;
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bg);
    ObjectSetInteger(0, name, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, 9);
    ObjectSetString(0, name, OBJPROP_TEXT, button_labels[i]);
    ObjectSetString(0, name, OBJPROP_TOOLTIP, button_desc[i]);
   }
 }

//+------------------------------------------------------------------+
//| Manejador de eventos del grÃ¡fico                                 |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
 {
// --- Clic en un botÃ³n del panel ---
  if(id == CHARTEVENT_OBJECT_CLICK)
   {
    // debug print (opcional)
    // Print("OBJ_CLICK: ", id, " ", lparam, " ", dparam, " '", sparam, "'");

    for(int i=0; i<ArraySize(buttons); i++)
     {
      if(sparam == buttons[i])
       {
        // BotÃ³n "ClearAll"
        if(sparam == "ClearAll")
         {
          ClearAllDrawings();
          wait_for_click = false;
          active_tool = "";
          for(int j=0; j<ArraySize(buttons); j++)
            ResetButtonColor(j);
          ChartRedraw();
          Print("ðŸ§¹ Todos los objetos TB_ eliminados.");
          return;
         }

        // BotÃ³n "Show" (toggle toolbox)
        if(sparam == "Show")
         {
          // invertir el booleano correctamente
          SwitchToolbox = !SwitchToolbox;

          if(!SwitchToolbox)
           {
            // ocultar todos excepto Show (los movemos fuera de pantalla)
            for(int k=0; k<ArraySize(buttons); k++)
             {
              if(buttons[k] != "Show")
               {
                // mover fuera de la vista
                ObjectSetInteger(0, buttons[k], OBJPROP_XDISTANCE, -1000);
                ObjectSetInteger(0, buttons[k], OBJPROP_YDISTANCE, -1000);
               }
             }
           }
          else
           {
            // mostrar: recrear panel centrado
            CreatePanel();
           }
          ChartRedraw();
          return;
         }

        // SelecciÃ³n de herramienta (cualquier otro botÃ³n)
        active_tool = buttons[i];
        wait_for_click = true;
        Print("Herramienta seleccionada: ", active_tool, " (esperando clic en grÃ¡fico)");

        // Resaltar botÃ³n activo y marcar su estado (visual pressed)
        for(int j=0; j<ArraySize(buttons); j++)
         {
          if(j == i)
           {
            ObjectSetInteger(0, buttons[j], OBJPROP_BGCOLOR, clrDarkOrange);
            ObjectSetInteger(0, buttons[j], OBJPROP_STATE, true); // marcar como presionado
           }
          else
           {
            ResetButtonColor(j);
            ObjectSetInteger(0, buttons[j], OBJPROP_STATE, false);
           }
         }
        ChartRedraw();
        return;
       }
     }
   }

// --- Recentrar si se cambia el tamaÃ±o del grÃ¡fico ---
  if(id == CHARTEVENT_CHART_CHANGE)
   {
    // Solo recrea si la toolbox estÃ¡ visible
    if(SwitchToolbox)
      CreatePanel();
    ChartRedraw();
   }

// --- Clic en el grÃ¡fico (para dibujar) ---
  if(id == CHARTEVENT_CLICK && active_tool != "" && wait_for_click)
   {
    int x = (int)lparam;
    int y = (int)dparam;

    // Ignorar clics dentro del Ã¡rea del panel (si visible)
    if(SwitchToolbox)
     {
      int chart_width = (int)ChartGetInteger(0, CHART_WIDTH_IN_PIXELS);
      int total_width = ArraySize(buttons) * (BTN_SIZE + 5);
      int panel_x = (chart_width - total_width) / 2;
      int panel_y = PANEL_Y;
      int panel_h = BTN_SIZE;

      if(x >= panel_x && x <= panel_x + total_width && y >= panel_y && y <= panel_y + panel_h)
        return; // clic dentro del panel, no dibujar
     }

    datetime click_time;
    double click_price;
    int subwindow = 0;

    if(ChartXYToTimePrice(0, x, y, subwindow, click_time, click_price))
     {
      DrawObject(active_tool, click_time, click_price);
      Print("Dibujado: ", active_tool, " en ", TimeToString(click_time), " @ ", DoubleToString(click_price, _Digits));
     }

    // Desactivar herramienta despuÃ©s de dibujar y "soltar" visualmente los botones
    active_tool = "";
    wait_for_click = false;

    for(int i=0; i<ArraySize(buttons); i++)
     {
      ResetButtonColor(i);
      ObjectSetInteger(0, buttons[i], OBJPROP_STATE, false);
     }
    ChartRedraw();
   }
 }

//+------------------------------------------------------------------+
//| Crear objeto segÃºn la herramienta seleccionada                  |
//+------------------------------------------------------------------+
void DrawObject(string tool, datetime t, double p)
 {
  string name = StringFormat("TB_%s_%d", tool, TimeLocal());

  if(tool == "HLine")
    ObjectCreate(0, name, OBJ_HLINE, 0, 0, p);
  else
    if(tool == "VLine")
      ObjectCreate(0, name, OBJ_VLINE, 0, t, 0);
    else
      if(tool == "Trend")
        ObjectCreate(0, name, OBJ_TREND, 0, t-3600, p, t, p);
      else
        if(tool == "Rect")
          ObjectCreate(0, name, OBJ_RECTANGLE, 0, t-1800, p+0.001, t, p-0.001);
        else
          if(tool == "Text")
           {
            ObjectCreate(0, name, OBJ_TEXT, 0, t, p);
            ObjectSetString(0, name, OBJPROP_TEXT, "Texto");
           }
          else
            if(tool == "Dot")
             {
              ObjectCreate(0, name, OBJ_ARROW, 0, t, p);
              ObjectSetInteger(0, name, OBJPROP_ARROWCODE, 159);
             }

// Si la creaciÃ³n fallÃ³, evitamos hacer set de propiedades en nombre invÃ¡lido
  if(ObjectFind(0, name) == -1)
    return;

  ObjectSetInteger(0, name, OBJPROP_COLOR, clrOrange);
  ObjectSetInteger(0, name, OBJPROP_WIDTH, 1);
  ObjectSetInteger(0, name, OBJPROP_SELECTABLE, true);
  ObjectSetInteger(0, name, OBJPROP_SELECTED, true);
 }

//+------------------------------------------------------------------+
//| Eliminar todos los objetos creados por el toolbox               |
//+------------------------------------------------------------------+
void ClearAllDrawings()
 {
  int total = ObjectsTotal(0);
  for(int i = total - 1; i >= 0; i--)
   {
    string name = ObjectName(0, i);
    if(StringFind(name, "TB_") == 0)
      ObjectDelete(0, name);
   }
  ChartRedraw();
 }

//+------------------------------------------------------------------+
//| Restaurar color de botÃ³n segÃºn tipo                             |
//+------------------------------------------------------------------+
void ResetButtonColor(int i)
 {
  string name = buttons[i];
  color bg = (name == "ClearAll") ? clrMaroon : clrDimGray;
  ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bg);
 }
//+------------------------------------------------------------------+

